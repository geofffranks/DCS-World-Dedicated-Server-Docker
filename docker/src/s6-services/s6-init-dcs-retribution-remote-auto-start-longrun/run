#!/usr/bin/with-contenv bash
# shellcheck shell=bash

# Source the log helper after setting the prefix
log_prefix="s6-init-dcs-retribution-remote-auto-start-longrun"
source /app/dcs_server/logger_function

handle_error() {
    local exit_code="$?"
    echo -e "Error occurred (Exit code: $exit_code)"
    exit "$exit_code"
}
trap handle_error ERR

# Get / set env vars and timeout value for server check interval.
AUTOSTART_RETRIBUTION_REMOTE="${AUTOSTART_RETRIBUTION_REMOTE:-0}"
TIMEOUT="${TIMEOUT:-30}"

# Check if ENABLE_DCS_RETRIBUTION environment variable is set to 1
if [ "${AUTOSTART_RETRIBUTION_REMOTE}" != "1" ]; then
    echo "AUTOSTART_RETRIBUTION_REMOTE is not set to 1. Exiting."
    sleep ${TIMEOUT}
    exit 0
fi

# Now start up the bot
while true; do
startup_iterator=1
pid=""
    if [ $startup_iterator -eq 1 ]; then
        echo "Starting Retribution Remote Control" 
        cd "/config/.wine/drive_c/users/abc/Saved Games/dcs-retribution-remote"
	sudo -E -u abc wine "/config/.wine/drive_c/users/abc/Saved Games/dcs-retribution-remote/retribution_remote.exe"
        pid=$! # This grabs the PID of the running Sneaker process and keeps it for later if needed.
        echo "Retribution Remote Control PID="$pid 
        startup_iterator=0
        #echo "Sleeping: $TIMEOUT"
        sleep $TIMEOUT
    fi
    while true; do
        # Check if the service is still alive.
        if ps -p "$pid" > /dev/null; then
            echo "############### Retribution Remote Control still running. ###############" $(date +"%d-%m-%y-%T") 
            #echo "Sleeping: $TIMEOUT"
            sleep $TIMEOUT
        else
            startup_iterator=1
            restarts=$((restarts + 1))
            break # Restart server
        fi
    done
done
